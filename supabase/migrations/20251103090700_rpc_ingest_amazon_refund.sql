-- 20251103_rpc_ingest_amazon_refund.sql
-- RPC ingest_amazon_refund: upsert refund + items (dédup par source_event_id), génération d&#39;avoir optionnelle

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'ingest_amazon_refund') THEN
    CREATE OR REPLACE FUNCTION public.ingest_amazon_refund(
      p_payload jsonb,
      p_user uuid
    )
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
    AS $$
    DECLARE
      v_source_event_id text := (p_payload->>'source_event_id');
      v_channel text := COALESCE(p_payload->>'channel','amazon');
      v_order_id text := p_payload->>'orderId';
      v_invoice_id uuid := NULL;  -- tentative de mapping possible ultérieurement
      v_refund_id uuid;
      v_credit_note_id uuid := NULL;
      v_processed_at timestamptz := COALESCE((p_payload->>'processed_at')::timestamptz, now());
      v_restock boolean := COALESCE((p_payload->>'restock_flag')::boolean, false);
      v_item jsonb;
      v_product_id uuid;
      v_unit_price numeric;
      v_qty numeric;
      v_vat_rate numeric;
      v_vat_regime text;
    BEGIN
      IF v_source_event_id IS NULL THEN
        RAISE EXCEPTION 'source_event_id required';
      END IF;

      -- UPSERT refund (dédup par source_event_id)
      INSERT INTO public.refunds(
        channel, invoice_id, order_id,
        refund_amount_gross, refund_taxable_base, refund_vat_amount, fees,
        reason_code, processed_at, source_event_id, source_report, created_by
      )
      VALUES (
        v_channel, NULL, v_order_id,
        COALESCE((p_payload->>'refund_amount_gross')::numeric,0),
        COALESCE((p_payload->>'refund_taxable_base')::numeric,0),
        COALESCE((p_payload->>'refund_vat_amount')::numeric,0),
        COALESCE((p_payload->>'fees')::numeric,0),
        p_payload->>'reason_code',
        v_processed_at,
        v_source_event_id,
        p_payload->>'source_report',
        p_user
      )
      ON CONFLICT (source_event_id) DO UPDATE
      SET processed_at = EXCLUDED.processed_at,
          order_id = COALESCE(EXCLUDED.order_id, public.refunds.order_id)
      RETURNING id INTO v_refund_id;

      -- Réinitialiser les items pour garantir idempotence
      DELETE FROM public.refund_items WHERE refund_id = v_refund_id;

      -- Insérer les items depuis payload.items
      FOR v_item IN SELECT * FROM jsonb_array_elements(COALESCE(p_payload->'items','[]'::jsonb)) LOOP
        SELECT id INTO v_product_id
        FROM public.products
        WHERE sku = v_item->>'sku'
        LIMIT 1;

        v_qty := COALESCE((v_item->>'qty')::numeric, 0);
        v_unit_price := COALESCE((v_item->>'unit_price')::numeric, 0);
        v_vat_rate := COALESCE((v_item->>'vat_rate')::numeric, 0);
        v_vat_regime := COALESCE(v_item->>'vat_regime','normal');

        INSERT INTO public.refund_items(refund_id, invoice_item_id, product_id, qty, unit_price, vat_rate, vat_regime)
        VALUES (v_refund_id, NULL, v_product_id, v_qty, v_unit_price, v_vat_rate, v_vat_regime);
      END LOOP;

      -- Tentative de correspondance facture par order_id/sku: non implémentée ici (laisser v_invoice_id NULL)
      -- Si vous disposez d&#39;un mapping invoices.order_id, vous pouvez l&#39;activer ici.

      -- Génération d&#39;un avoir automatique si la facture est connue (placeholder)
      IF v_invoice_id IS NOT NULL THEN
        INSERT INTO public.credit_notes(invoice_id, credit_note_number, date_issued, status, note, created_at)
        VALUES (v_invoice_id, NULL, v_processed_at::date, 'processed', 'Generated by refund event '||v_source_event_id, now())
        RETURNING id INTO v_credit_note_id;

        -- Mapping refund_items -> credit_note_items à implémenter si nécessaire (par invoice_item_id/sku)
        -- Optionnel: si v_restock = true, ré-entrée stock après publication via process_credit_note(v_credit_note_id, p_user)
      END IF;

      RETURN jsonb_build_object(
        'status','ok',
        'refund_id',v_refund_id,
        'matched_invoice_id',v_invoice_id,
        'credit_note_id',v_credit_note_id,
        'restock_flag',v_restock
      );
    END;
    $$;
  END IF;
END
$$;

GRANT EXECUTE ON FUNCTION public.ingest_amazon_refund(jsonb, uuid) TO authenticated;
